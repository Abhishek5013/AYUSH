/**
 * @fileoverview Firestore Security Rules for QuizWise application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for private user data
 * while allowing public read access to quizzes. It uses denormalization to
 * simplify and optimize authorization checks.
 *
 * Data Structure:
 * - /users/{userId}: Stores private user profiles. Only the user can read/write their own profile.
 * - /quizzes/{quizId}: Stores public quiz data. Anyone can read quizzes, but only the owner can modify them.
 * - /quizzes/{quizId}/questions/{questionId}: Stores questions for a specific quiz. Only the quiz owner can manage questions.
 * - /users/{userId}/quiz_attempts/{quizAttemptId}: Stores quiz attempts for a specific user. Only the user can read/write their own attempts.
 * - /users/{userId}/quiz_attempts/{quizAttemptId}/feedback/{feedbackId}: Stores feedback for a specific quiz attempt. Only the user can read/write their own feedback.
 * - /roles_admin/{userId}: Stores admin roles. Existence of a document indicates admin privileges for the user.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Public read access is granted to the /quizzes collection.
 * - Ownership is enforced using the `ownerId` field on quizzes and is denormalized to child collections.
 * - Admin roles are determined by the existence of a document in the `/roles_admin/{userId}` collection.
 *
 * Denormalization for Authorization:
 * - Quiz documents have an `ownerId` field representing the quiz creator.
 * - Question documents have a `quizOwnerId` field denormalized from the parent quiz.
 * - Feedback documents have a `userOwnerId` field denormalized from the parent quiz attempt.
 *
 * Structural Segregation:
 * - Private user data (quiz attempts, feedback) is stored under /users/{userId}.
 * - Public quiz data is stored in the top-level /quizzes collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces that only the authenticated user can read/write their own user document.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' tries to create profile for 'user456': request.auth.uid == 'user123'
     * @allow (get, update, delete) User with ID 'user123' reads/writes their profile: request.auth.uid == 'user123'
     * @deny (get, update, delete) User with ID 'user123' tries to read/write profile for 'user456': request.auth.uid == 'user123'
     * @principle Enforces document ownership for reads and writes.
     */
    match /users/{userId} {
      // Helper function to check if the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the request is made by the owner of the document.
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      // Helper function to check if the request is made by the existing owner of the document, must be used for destructive operations
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // User listing is not allowed.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to quizzes but restricts write access to the owner.
     * @path /quizzes/{quizId}
     * @allow (get, list) Any user can read quizzes.
     * @allow (create) User with ID 'user123' creates a quiz with ownerId 'user123': request.auth.uid == 'user123' && request.resource.data.ownerId == 'user123'
     * @deny (create) User with ID 'user123' tries to create a quiz with ownerId 'user456': request.auth.uid == 'user123' && request.resource.data.ownerId == 'user456'
     * @allow (update, delete) User with ID 'user123' updates/deletes their quiz (ownerId is 'user123'): request.auth.uid == 'user123' && resource.data.ownerId == 'user123'
     * @deny (update, delete) User with ID 'user123' tries to update/delete a quiz owned by 'user456': request.auth.uid == 'user123' && resource.data.ownerId == 'user456'
     * @principle Allows public read access with owner-only writes.
     */
    match /quizzes/{quizId} {
      // Helper function to check if the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the request is made by the owner of the quiz.
      function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }

      function isExistingOwner(ownerId) {
        return isOwner(ownerId) && resource != null;
      }

      allow get, list: if true; // Public read access.
      allow create: if isSignedIn() && isOwner(request.resource.data.ownerId);
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Enforces that only the quiz owner can manage questions for their quiz.
     * @path /quizzes/{quizId}/questions/{questionId}
     * @allow (create) User with ID 'user123' creates a question for their quiz (quizOwnerId is 'user123'): request.auth.uid == 'user123' && request.resource.data.quizOwnerId == 'user123'
     * @deny (create) User with ID 'user123' tries to create a question for a quiz owned by 'user456': request.auth.uid == 'user123' && request.resource.data.quizOwnerId == 'user456'
     * @allow (get, list, update, delete) User with ID 'user123' reads/writes questions for their quiz (quizOwnerId is 'user123'): request.auth.uid == 'user123' && resource.data.quizOwnerId == 'user123'
     * @deny (get, list, update, delete) User with ID 'user123' tries to read/write questions for a quiz owned by 'user456': request.auth.uid == 'user123' && resource.data.quizOwnerId == 'user456'
     * @principle Enforces document ownership for writes, with denormalized owner ID.
     */
    match /quizzes/{quizId}/questions/{questionId} {
      // Helper function to check if the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the request is made by the owner of the quiz (denormalized).
      function isOwner(quizOwnerId) {
        return request.auth.uid == quizOwnerId;
      }

      function isExistingOwner(quizOwnerId) {
        return isOwner(quizOwnerId) && resource != null;
      }

      allow get, list: if isOwner(resource.data.quizOwnerId);
      allow create: if isSignedIn() && isOwner(request.resource.data.quizOwnerId);
      allow update: if isExistingOwner(resource.data.quizOwnerId);
      allow delete: if isExistingOwner(resource.data.quizOwnerId);
    }

    /**
     * @description Enforces that only the authenticated user can read/write their own quiz attempts.
     * @path /users/{userId}/quiz_attempts/{quizAttemptId}
     * @allow (create) User with ID 'user123' creates a quiz attempt under their user ID: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' tries to create a quiz attempt under user ID 'user456': request.auth.uid == 'user123'
     * @allow (get, list, update, delete) User with ID 'user123' reads/writes their quiz attempts: request.auth.uid == 'user123'
     * @deny (get, list, update, delete) User with ID 'user123' tries to read/write quiz attempts for user 'user456': request.auth.uid == 'user123'
     * @principle Enforces document ownership for reads and writes under the user's data tree.
     */
    match /users/{userId}/quiz_attempts/{quizAttemptId} {
      // Helper function to check if the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the request is made by the owner of the document.
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces that only the authenticated user can read/write their own quiz attempt feedback.
     * @path /users/{userId}/quiz_attempts/{quizAttemptId}/feedback/{feedbackId}
     * @allow (create) User with ID 'user123' creates feedback under their quiz attempt: request.auth.uid == 'user123' && request.resource.data.userOwnerId == 'user123'
     * @deny (create) User with ID 'user123' tries to create feedback under a quiz attempt for user 'user456': request.auth.uid == 'user123' && request.resource.data.userOwnerId == 'user456'
     * @allow (get, list, update, delete) User with ID 'user123' reads/writes their feedback: request.auth.uid == 'user123' && resource.data.userOwnerId == 'user123'
     * @deny (get, list, update, delete) User with ID 'user123' tries to read/write feedback for user 'user456': request.auth.uid == 'user123' && resource.data.userOwnerId == 'user456'
     * @principle Enforces document ownership for reads and writes, with denormalized owner ID.
     */
    match /users/{userId}/quiz_attempts/{quizAttemptId}/feedback/{feedbackId} {
      // Helper function to check if the user is signed in.
      function isSignedIn() {
        return request.auth != null;
      }

      // Helper function to check if the request is made by the owner of the quiz attempt (denormalized).
      function isOwner(userOwnerId) {
        return request.auth.uid == userOwnerId;
      }

      function isExistingOwner(userOwnerId) {
        return isOwner(userOwnerId) && resource != null;
      }

      allow get, list: if isOwner(resource.data.userOwnerId);
      allow create: if isSignedIn() && isOwner(request.resource.data.userOwnerId);
      allow update: if isExistingOwner(resource.data.userOwnerId);
      allow delete: if isExistingOwner(resource.data.userOwnerId);
    }

        /**
     * @description Grants admin privileges based on the existence of a document in this collection.
     * @path /roles_admin/{userId}
     * @allow (create) User with ID 'user123' creates an admin role for themselves: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user123' tries to create an admin role for 'user456': request.auth.uid == 'user123'
     * @allow (get, update, delete) User with ID 'user123' manages their admin role: request.auth.uid == 'user123'
     * @deny (get, update, delete) User with ID 'user123' tries to manage admin role for 'user456': request.auth.uid == 'user123'
     * @principle Uses document existence to grant admin privileges.
     */
        match /roles_admin/{userId} {
            // Helper function to check if the user is signed in.
            function isSignedIn() {
                return request.auth != null;
            }

            // Helper function to check if the request is made by the owner of the document.
            function isOwner(userId) {
                return request.auth.uid == userId;
            }

            function isAdmin() {
                return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
            }

            allow get: if isAdmin();
            allow list: if false;
            allow create: if isSignedIn() && isOwner(userId);
            allow update: if false; // Admin roles are not directly editable.
            allow delete: if isSignedIn() && isOwner(userId); // Admin roles can be removed
        }
  }
}